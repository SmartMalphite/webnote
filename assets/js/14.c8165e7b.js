(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{735:function(t,s,n){"use strict";n.r(s);var a=n(103),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"协程与线程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#协程与线程"}},[t._v("#")]),t._v(" 协程与线程")]),t._v(" "),n("p",[t._v("​\t大家都知道，协程被称作是一个轻量级的线程。那么他们具体的区别是什么呢？")]),t._v(" "),n("blockquote",[n("p",[t._v("1.栈的大小")])]),t._v(" "),n("p",[t._v("​\t我们知道，线程是有固定的栈的，基本都是2MB，当然，不同系统可能大小不太一样，但是的确都是固定分配的。这个栈用于保存局部变量，用于在函数切换时使用。但是对于goroutine这种轻量级的协程来说，一个大小固定的栈可能会导致资源浪费：比如一个协程里面只print了一个语句，那么栈基本没怎么用；当然，也有可能嵌套调用很深，那么可能也不够用。所以go采用了动态扩张收缩的策略：初始化为2KB，最大可扩张到1GB。")]),t._v(" "),n("blockquote",[n("p",[t._v("2.goroutine没有id")])]),t._v(" "),n("p",[t._v("​\t每个线程都有一个id，这个在线程创建时就会返回，所以可以很方便的通过id操作某个线程。但是在goroutine内没有这个概念，这个是go语言设计之初考虑的，防止被滥用，所以你不能在一个协程中杀死另外一个协程，编码时需要考虑到协程什么时候创建，什么时候释放。")]),t._v(" "),n("blockquote",[n("p",[t._v("3.GOMAXPROCS")])]),t._v(" "),n("p",[t._v("​\t用于设置上下文个数，这个上下文用于协程间的切换，默认值是CPU的个数，也就是说这个个数是指定"),n("strong",[t._v("同时执行协程的OS线程数")]),t._v("）。这么说可能抽象一点，《The Go Programming Language》这本书里举了个例子：")]),t._v(" "),n("div",{staticClass:"language-go extra-class"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v(" fmt"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    fmt"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n$ GOMAXPROCS"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v(" run example"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("11111111111111111100000000000000000000111111111.")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("  \n$ GOMAXPROCS"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v(" run example"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("01010101010010101001110010101010010101010101010.")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" \n")])])]),n("blockquote",[n("p",[t._v("4.goroutine调度")])]),t._v(" "),n("p",[t._v("​\t总的来说就是，协程和线程的区别在于：线程切换需要陷入内核，然后进行上下文切换，而协程在用户态由协程调度器完成，不需要陷入内核，这代价就小了；另外，协程的切换时间点是由调度器决定的，而不是系统内核决定的，尽管他们切换点都是时间片超过一定阈值，或者进入I/O或睡眠等状态；再次，还有垃圾回收的考虑，因为go实现了垃圾回收，而垃圾回收的必要条件时内存位于一致状态，这就需要暂停所有的线程，如果交给系统去做，那么会暂停所有的线程使其一致，而在go里面调度器知道什么时候内存位于一致状态，那么就没有必要暂停所有运行的协程。")]),t._v(" "),n("p",[t._v("常见的三种映射模型")]),t._v(" "),n("ul",[n("li",[t._v("一对一模型（1:1）。一个用户线程映射到一个内核线程，用户线程在存活期都会绑定到一个内核线程，一旦退出，2个线程都会退出。优点是实现了真正的并发，多个线程同时跑在不同的CPU上；缺点是，如果用户线程起多了，内核线程肯定不够用，那么就需要切换，涉及到上下文的切换，代价比较大。")]),t._v(" "),n("li",[t._v("多对一模型（M:1）。多个用户线程映射到一个内核线程。优点是，多个用户线程切换比较快，不需要内核线程上下文切换；缺点是，如果一个线程阻塞了，那么映射到同一个内核线程的用户线程将都无法运行。")]),t._v(" "),n("li",[t._v("多对多模型（M:N）。综合以上两种模型，go采用的就是这种。下面进行具体介绍。")])]),t._v(" "),n("p",[t._v("go调度里面有三个角色：三角形M代表内核线程，正方形P代表上下文，圆形G代表协程:")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/555.png",alt:"555"}})]),t._v(" "),n("p",[t._v("下面图我们看到他们之间的对应规则：一个M对应一个P，一个P下面挂多个G，但一个时候只有一个G在跑，其余都是放入等待队列，等待下一次切换时使用。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/666.png",alt:"666"}})]),t._v(" "),n("p",[t._v("那么假如一个运行的协程G调用syscall进入阻塞怎么办？如下图左边，G0进入阻塞，那么P会转移到另外一个内核线程M1（此时还是1对1）。当syscall返回后，需要抢占一个P继续执行，如果抢占不到，G0挂入全局就绪队列runqueue，等待下次调度，理论上会被挂入到一个具体P下面的就绪队列runqueu（区别于全局runqueue）。\n"),n("img",{attrs:{src:"https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/777.png",alt:"777"}})]),t._v(" "),n("p",[t._v("假如一个P0下面的所有G都跑完了，怎么办？这时候会从别的P1下面就绪队列抢占G进行运行，个数为P1就绪队列的一半。\n"),n("img",{attrs:{src:"https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/888.png",alt:"888"}})]),t._v(" "),n("h2",{attrs:{id:"代码演示"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码演示"}},[t._v("#")]),t._v(" 代码演示")]),t._v(" "),n("div",{staticClass:"language-go extra-class"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" main\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n   "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"fmt"')]),t._v("\n   "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"time"')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//使用go代表该函数放入协程运行")]),t._v("\n         fmt"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("   "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//注意 为了避免出现竞争 要进行参数传递(因为go都是值传递)")]),t._v("\n   "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n   "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//错误示范如下")]),t._v("\n   "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" q"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("q"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("q"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n         fmt"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("q"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//虽然这样也可以访问i 但是由于共享变量 会出现竞争")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   \n   time"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Sleep")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("time"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Second"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);