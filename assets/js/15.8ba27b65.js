(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{733:function(t,n,e){"use strict";e.r(n);var a=e(103),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"什么是channel"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是channel"}},[t._v("#")]),t._v(" 什么是Channel")]),t._v(" "),e("p",[t._v("Channel 是 Go 中为 goroutine 提供的一种通信机制，channel 是有类型的，而且是有方向的，可以把 channel 类比成 unix 中的 pipe。")]),t._v(" "),e("h2",{attrs:{id:"channel的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channel的使用"}},[t._v("#")]),t._v(" channel的使用")]),t._v(" "),e("h3",{attrs:{id:"channel创建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channel创建"}},[t._v("#")]),t._v(" channel创建")]),t._v(" "),e("p",[t._v("channel 字面意义是 “通道”，类似于 Linux 中的管道。声明 channel 的语法如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("chan T          // 可以接收和发送类型为 T 的数据\nchan<- float64  // 只可以用来发送 float64 类型的数据\n<-chan int      // 只可以用来接收 int 类型的数据\n")])])]),e("p",[t._v("使用make初始化Channel,并且可以设置容量:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("make(chan int, 100)\n")])])]),e("p",[t._v("因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。")]),t._v(" "),e("p",[t._v("Channel 分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作 “同步模式”，带缓冲的则称为 “异步模式”。")]),t._v(" "),e("p",[e("code",[t._v("同步模式")]),t._v("下，发送方和接收方要同步就绪，只有在两者都 ready 的情况下，数据才能在两者间传输。否则，任意一方先行进行发送或接收操作，都会被挂起，等待另一方的出现才能被唤醒。")]),t._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/1728a8bca1fc4c1f-20200614165223500.png"}}),t._v(" "),e("p",[e("code",[t._v("异步模式")]),t._v("下，在缓冲槽可用的情况下（有剩余容量），发送和接收操作都可以顺利进行。否则，操作的一方（如写入）同样会被挂起，直到出现相反操作（如接收）才会被唤醒。")]),t._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/1728a8bca1fc4c1f-20200614165223500-20200822180035466.png"}}),t._v(" "),e("h4",{attrs:{id:"代码示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码示例"}},[t._v("#")]),t._v(" 代码示例")]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//这里定义两个函数，下面分别验证同步模式执行以及异步模式执行的效果")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("service")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\ttime"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Sleep")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("time"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Millisecond "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Done"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("otherTask")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tfmt"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"this is other task B"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\ttime"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Sleep")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("time"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Millisecond "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tfmt"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Task B is done"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("同步模式执行")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('func AsyncService() chan string { \n\t//阻塞模式，即A将信息放进channel直到有人读取，否则将一直阻塞\t\n\tretCh := make(chan string) \n\tgo func () {\n\t\tret := service()\n\t\tfmt.Println("service return result")\n\t\tretCh <- ret \n\t\tfmt.Println("service exited")\n\t}()\n\treturn retCh\n}\n\n//单元测试\nfunc TestAsynService(t *testing.T) {\n\tretCh := AsyncService()\n\totherTask()\n\tfmt.Println(<-retCh)\n\ttime.Sleep(time.Second * 1)\n}\n')])])]),e("p",[t._v("单测结果运行如下,可以看出等到当othertask执行完开始从chan中取数据时协程才继续向下执行，在这之前一直处于挂起状态")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("this is other task B\nservice return result\nTask B is done\nDone\nservice exited\n")])])]),e("p",[t._v("异步模式执行")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('func AsyncService() chan string { \n\tretCh := make(chan string,1) //buffer模式，非阻塞 丢进channel就继续向下执行\n\tgo func () {\n\t\tret := service()\n\t\tfmt.Println("service return result")\n\t\tretCh <- ret \n\t\tfmt.Println("service exited")\n\t}()\n\treturn retCh\n}\n\nfunc TestAsynService(t *testing.T) {\n\tretCh := AsyncService()\n\totherTask()\n\tfmt.Println(<-retCh)\n\ttime.Sleep(time.Second * 1)\n}\n')])])]),e("p",[t._v("执行结果如下，可以明显的看到这种模式下并没有等待从chan中获取消息，直接向下继续运行")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("this is other task\nservice return result\nservice exited\nTask B is done\nDone\n")])])]),e("h3",{attrs:{id:"channel操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channel操作"}},[t._v("#")]),t._v(" channel操作")]),t._v(" "),e("p",[t._v("1.send操作")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("c := make(chan int)\nc <- 3\n")])])]),e("p",[t._v("注意，往一个已经被close的channel中继续发送数据会导致"),e("code",[t._v("run-time panic")])]),t._v(" "),e("p",[t._v("2.recive操作")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("c := make(chan int)\nc <- 3\ni := <-c\nfmt.Println(i) //3\n")])])]),e("p",[t._v("从一个nil channel中接收数据会一直被block,直到有数据可以接收；从一个被close的channel中接收数据不会被阻塞，而是立即返回，会返回元素类型的零值(zero value)以及一个代表当前channel状态的bool值。可以通过这个特性判断channel是否关闭")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("if x, ok := <-ch;ok {    //ok 为bool值，true标识正常接收，false表示通道关闭\n    ...\n}else{\n    ...\n} \n")])])]),e("p",[t._v("3.close操作")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("c := make(chan int)\nclose(c)\n")])])]),e("p",[t._v("所有的channel接受者都会在channel关闭时，立刻从阻塞等待中返回且上述ok值为false(如果有值可取依旧会正常取值)。这个广播机制常被利用，进行向多个订阅者同时发送信号")]),t._v(" "),e("h4",{attrs:{id:"代码示例-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码示例-2"}},[t._v("#")]),t._v(" 代码示例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//数据生产者\nfunc dataProducer(ch chan int, wg *sync.WaitGroup) {\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tch <- i\n\t\t}\n\t\tclose(ch)\t//channel关闭\n\n\t\twg.Done()\n\t}()\n\n}\n\n//数据接受者\nfunc dataReceiver(ch chan int, wg *sync.WaitGroup) {\n\tgo func() {\n\t\tfor {\n\t\t\tif data, ok := <-ch; ok {\t//channel关闭后，ok值将变为false\n\t\t\t\tfmt.Println(data)\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\twg.Done()\n\t}()\n\n}\n\nfunc TestCloseChannel(t *testing.T) {\n\tvar wg sync.WaitGroup\n\tch := make(chan int)\n\twg.Add(1)\n\tdataProducer(ch, &wg)\n\twg.Add(1)\n\tdataReceiver(ch, &wg)\n\twg.Wait()\n")])])]),e("h3",{attrs:{id:"与switch-case搭配实现选路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与switch-case搭配实现选路"}},[t._v("#")]),t._v(" 与switch-case搭配实现选路")]),t._v(" "),e("p",[t._v("select-case语句配合channel可以实现多路选择以及超时控制功能，每个case后面跟一个阻塞事件，当有事件收到响应后则结束等待，如果均没有响应则执行default")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('//多渠道选择\n//原理如下，采用select-case语句 每个case后面跟一个阻塞事件，当有事件收到响应后则结束等待，如果均没有响应则执行default\nfunc TestSwitch(t *testing.T){\n\tselect{\n\t\tcase ret1 := <-retCH1:\n\t\t\tt.Logf("case 1 return")\n\t\tcase ret2 := <-retCH2:\n\t\t\tt.Logf("case 2 return")\n\t\tdefault:\n\t\t\tt.Logf("no one return")\n\t}\n}\n\n//超时控制\nfunc TestTimeOut(t *testing.T){\n\tselect {\n\tcase ret := <- retCH1:\n\t\tt.Logf("case 1 return")\n\tcase <-time.After(time.Second*1):\n\t\tt.Logf("time out")\n\t}\n}\n')])])])])}),[],!1,null,null,null);n.default=s.exports}}]);